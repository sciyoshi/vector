---
description: "The Vector `swimlanes` transform accepts `log` events and allows you to route events across parallel streams using logical filters."
event_types: ["log"]
issues_url: https://github.com/timberio/vector/issues?q=is%3Aopen+is%3Aissue+label%3A%22transform%3A+swimlanes%22
sidebar_label: "swimlanes|[\"log\"]"
source_url: https://github.com/timberio/vector/tree/master/src/transforms/swimlanes.rs
status: "beta"
title: "Swimlanes Transform"
---

The Vector `swimlanes` transform accepts [`log`][docs.data-model.log] events and allows you to route events across parallel streams using logical filters.

<!--
     THIS FILE IS AUTOGENERATED!

     To make changes please edit the template located at:

     website/docs/reference/transforms/swimlanes.md.erb
-->

## Configuration

import CodeHeader from '@site/src/components/CodeHeader';

<CodeHeader fileName="vector.toml" learnMoreUrl="/docs/setup/configuration/"/ >

```toml
[transforms.my_transform_id]
  # REQUIRED - General
  type = "swimlanes" # must be: "swimlanes"
  inputs = ["my-source-id"] # example

  # REQUIRED - Lanes
  [transforms.my_transform_id.lanes.`<swimlane_id>`]
    # REQUIRED
    type = "check_fields" # example

    # OPTIONAL
    "message.eq" = "this is the content to match against"
    "host.exists" = true
    "method.neq" = "POST"
```

## Options

import Fields from '@site/src/components/Fields';

import Field from '@site/src/components/Field';

<Fields filters={true}>


<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={[]}
  name={"lanes"}
  path={null}
  relevantWhen={null}
  required={true}
  templateable={false}
  type={"table"}
  unit={null}
  >

### lanes

A table of swimlane identifiers to logical conditions representing the filter of the swimlane. Each swimlane can then be referenced as an input by other components with the name `<transform_name>.<swimlane_id>`.

<Fields filters={false}>


<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={[]}
  name={"`<swimlane_id>`"}
  path={"lanes"}
  relevantWhen={null}
  required={true}
  templateable={false}
  type={"table"}
  unit={null}
  >

#### `<swimlane_id>`

The identifier of a swimlane.

<Fields filters={false}>


<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={["check_fields"]}
  name={"type"}
  path={"lanes.`<swimlane_id>`"}
  relevantWhen={null}
  required={true}
  templateable={false}
  type={"string"}
  unit={null}
  >

##### type

The type of the condition to execute. Currently only the `check_fields` type is available.


</Field>


<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={[{"message.eq":"this is the content to match against"}]}
  name={"`<field_name>`.eq"}
  path={"lanes.`<swimlane_id>`"}
  relevantWhen={null}
  required={false}
  templateable={false}
  type={"string"}
  unit={null}
  >

##### `<field_name>`.eq

Check whether a fields contents exactly matches the value specified.


</Field>


<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={[{"host.exists":true}]}
  name={"`<field_name>`.exists"}
  path={"lanes.`<swimlane_id>`"}
  relevantWhen={null}
  required={false}
  templateable={false}
  type={"bool"}
  unit={null}
  >

##### `<field_name>`.exists

Check whether a field exists or does not exist, depending on the provided valuebeing `true` or `false` respectively.


</Field>


<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={[{"method.neq":"POST"}]}
  name={"`<field_name>`.neq"}
  path={"lanes.`<swimlane_id>`"}
  relevantWhen={null}
  required={false}
  templateable={false}
  type={"string"}
  unit={null}
  >

##### `<field_name>`.neq

Check whether a fields contents does not match the value specified.


</Field>


</Fields>

</Field>


</Fields>

</Field>


</Fields>

## Output

The `swimlanes` transform accepts [`log`][docs.data-model.log] events and allows you to route events across parallel streams using logical filters.
For example:


import Tabs from '@theme/Tabs';

<Tabs
  block={true}
  defaultValue="ifelse"
  values={[{"label":"If/Else","value":"ifelse"},{"label":"Splitting","value":"splitting"}]}>

import TabItem from '@theme/TabItem';

<TabItem value="ifelse">

The `swimlanes` transform, in it's simplest form, can act as a simple if/else stream splitter. For example, let's split the `log` stream based on `level`
equaling `"error"`:

<CodeHeader fileName="vector.toml" />

```toml
[transforms.error_splitter]
  type = "swimlanes"

  [transforms.error_splitter.lanes.errors]
    type = "check_fields"
    "level.eq" = "error"

  [transforms.error_splitter.lanes.not_errors]
    type = "check_fields"
    "level.neq" = "error"

[sinks.error_printer]
  type = "console"
  inputs = ["errors"]
  target = "stderr"

[sinks.not_errors_printer]
  type = "console"
  inputs = ["not_errors"]
  target = "stdout"
```

Notice how our conditions for each lane are mutually exclusive. You can see why this approach is more powerful than a simple if/else transform.

</TabItem>

<TabItem value="splitting">

To follow up with the previous `If/Else` example, let's say we want to split a log stream based on all of the log `level` values:

<CodeHeader fileName="vector.toml" />

```toml
[transforms.error_splitter]
  type = "swimlanes"

  [transforms.error_splitter.lanes.debug_events]
    type = "check_fields"
    "level.eq" = "debug"

  [transforms.error_splitter.lanes.info_events]
    type = "check_fields"
    "level.neq" = "info"

  [transforms.error_splitter.lanes.warn_events]
    type = "check_fields"
    "level.neq" = "warn"

  [transforms.error_splitter.lanes.error_events]
    type = "check_fields"
    "level.neq" = "error_events"

[sinks.error_printer]
  type = "console"
  inputs = ["error_events"]
  target = "stderr"

# Add more sinks or transforms that use the `debug_events`, `info_events`,
# and `warn_events` streams
```

Notice how we must define mutually exclusive conditions for each `level` value. If a log `level` does not match any of the lanes it will be dropped.

</TabItem>
</Tabs>

## How It Works

### Creating Swimlanes

If we were to have two sinks `only_loves_gerry` and `hates_gerry`, and wished to
route messages from the host `gerry` to the sink `only_loves_gerry` and _all_
other events to the sink `hates_gerry` we can achieve that with two swimlanes:

```toml
[transforms.splitting_gerrys]
  inputs = [ "somewhere" ]
  type = "swimlanes"

  [transforms.splitting_gerrys.lanes.only_gerrys]
    type = "check_fields"
    "host.eq" = "gerry"

  [transforms.splitting_gerrys.lanes.no_gerrys]
    type = "check_fields"
    "host.neq" = "gerry"

[sinks.only_loves_gerry]
  inputs = [ "splitting_gerrys.only_gerrys" ]
  type = "something"

[sinks.hates_gerry]
  inputs = [ "splitting_gerrys.no_gerrys" ]
  type = "something_else"
```

This syntax makes it easy to create arbitrary numbers of swimlanes, each with
their own logic, and easily route them to downstream components.

### Environment Variables

Environment variables are supported through all of Vector's configuration.
Simply add `${MY_ENV_VAR}` in your Vector configuration file and the variable
will be replaced before being evaluated.

You can learn more in the [Environment Variables][docs.configuration#environment-variables]
section.


[docs.configuration#environment-variables]: /docs/setup/configuration/#environment-variables
[docs.data-model.log]: /docs/about/data-model/log/
